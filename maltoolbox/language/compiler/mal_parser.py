# mypy: ignore-errors
# Generated from mal.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,51,413,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,1,0,4,0,92,8,0,
        11,0,12,0,93,1,0,3,0,97,8,0,1,1,1,1,1,1,1,1,3,1,103,8,1,1,2,1,2,
        1,2,1,3,1,3,1,3,1,3,1,3,1,4,1,4,1,4,5,4,116,8,4,10,4,12,4,119,9,
        4,1,4,1,4,5,4,123,8,4,10,4,12,4,126,9,4,1,4,1,4,1,5,1,5,1,5,1,5,
        1,5,1,6,1,6,1,7,3,7,138,8,7,1,7,1,7,1,7,1,7,3,7,144,8,7,1,7,5,7,
        147,8,7,10,7,12,7,150,9,7,1,7,1,7,1,7,5,7,155,8,7,10,7,12,7,158,
        9,7,1,7,1,7,1,8,1,8,1,8,5,8,165,8,8,10,8,12,8,168,9,8,1,8,3,8,171,
        8,8,1,8,3,8,174,8,8,1,8,5,8,177,8,8,10,8,12,8,180,9,8,1,8,5,8,183,
        8,8,10,8,12,8,186,9,8,1,8,3,8,189,8,8,1,8,3,8,192,8,8,1,9,1,9,1,
        10,1,10,1,10,1,11,1,11,1,11,1,11,5,11,203,8,11,10,11,12,11,206,9,
        11,1,11,1,11,1,12,1,12,1,13,1,13,1,14,1,14,1,14,1,14,1,15,1,15,1,
        15,5,15,221,8,15,10,15,12,15,224,9,15,1,16,1,16,1,16,5,16,229,8,
        16,10,16,12,16,232,9,16,1,17,1,17,1,17,3,17,237,8,17,1,18,1,18,1,
        18,1,18,1,18,1,18,3,18,245,8,18,1,19,1,19,1,19,1,19,1,19,5,19,252,
        8,19,10,19,12,19,255,9,19,3,19,257,8,19,1,19,3,19,260,8,19,1,20,
        1,20,3,20,264,8,20,1,20,1,20,3,20,268,8,20,1,20,3,20,271,8,20,1,
        21,1,21,1,22,1,22,1,22,5,22,278,8,22,10,22,12,22,281,9,22,1,23,1,
        23,1,23,1,23,5,23,287,8,23,10,23,12,23,290,9,23,1,23,1,23,1,24,1,
        24,1,24,1,25,1,25,1,26,1,26,1,27,1,27,1,28,1,28,1,29,1,29,1,29,1,
        29,5,29,309,8,29,10,29,12,29,312,9,29,1,30,1,30,1,30,1,30,5,30,318,
        8,30,10,30,12,30,321,9,30,1,31,1,31,1,32,1,32,1,32,1,32,1,32,1,33,
        1,33,1,33,1,33,5,33,334,8,33,10,33,12,33,337,9,33,1,34,1,34,1,34,
        5,34,342,8,34,10,34,12,34,345,9,34,1,35,1,35,1,35,1,35,1,35,1,35,
        1,35,1,35,1,35,3,35,356,8,35,1,35,3,35,359,8,35,1,35,5,35,362,8,
        35,10,35,12,35,365,9,35,1,36,1,36,1,37,1,37,1,37,1,37,1,38,1,38,
        1,39,1,39,1,39,5,39,378,8,39,10,39,12,39,381,9,39,1,39,1,39,1,40,
        1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,5,40,395,8,40,10,40,
        12,40,398,9,40,1,41,1,41,1,41,1,41,1,42,1,42,1,42,3,42,407,8,42,
        1,43,1,43,1,44,1,44,1,44,0,0,45,0,2,4,6,8,10,12,14,16,18,20,22,24,
        26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,
        70,72,74,76,78,80,82,84,86,88,0,10,1,0,9,10,4,0,13,13,22,22,36,37,
        39,39,1,0,14,16,2,0,31,31,45,45,2,0,28,28,46,46,2,0,38,38,48,48,
        1,0,42,43,1,0,11,12,1,0,31,33,2,0,11,11,28,28,411,0,96,1,0,0,0,2,
        102,1,0,0,0,4,104,1,0,0,0,6,107,1,0,0,0,8,112,1,0,0,0,10,129,1,0,
        0,0,12,134,1,0,0,0,14,137,1,0,0,0,16,161,1,0,0,0,18,193,1,0,0,0,
        20,195,1,0,0,0,22,198,1,0,0,0,24,209,1,0,0,0,26,211,1,0,0,0,28,213,
        1,0,0,0,30,217,1,0,0,0,32,225,1,0,0,0,34,233,1,0,0,0,36,244,1,0,
        0,0,38,246,1,0,0,0,40,261,1,0,0,0,42,272,1,0,0,0,44,274,1,0,0,0,
        46,282,1,0,0,0,48,293,1,0,0,0,50,296,1,0,0,0,52,298,1,0,0,0,54,300,
        1,0,0,0,56,302,1,0,0,0,58,304,1,0,0,0,60,313,1,0,0,0,62,322,1,0,
        0,0,64,324,1,0,0,0,66,329,1,0,0,0,68,338,1,0,0,0,70,355,1,0,0,0,
        72,366,1,0,0,0,74,368,1,0,0,0,76,372,1,0,0,0,78,374,1,0,0,0,80,384,
        1,0,0,0,82,399,1,0,0,0,84,403,1,0,0,0,86,408,1,0,0,0,88,410,1,0,
        0,0,90,92,3,2,1,0,91,90,1,0,0,0,92,93,1,0,0,0,93,91,1,0,0,0,93,94,
        1,0,0,0,94,97,1,0,0,0,95,97,5,0,0,1,96,91,1,0,0,0,96,95,1,0,0,0,
        97,1,1,0,0,0,98,103,3,4,2,0,99,103,3,6,3,0,100,103,3,8,4,0,101,103,
        3,78,39,0,102,98,1,0,0,0,102,99,1,0,0,0,102,100,1,0,0,0,102,101,
        1,0,0,0,103,3,1,0,0,0,104,105,5,5,0,0,105,106,5,9,0,0,106,5,1,0,
        0,0,107,108,5,22,0,0,108,109,5,17,0,0,109,110,5,23,0,0,110,111,5,
        9,0,0,111,7,1,0,0,0,112,113,5,6,0,0,113,117,5,17,0,0,114,116,3,10,
        5,0,115,114,1,0,0,0,116,119,1,0,0,0,117,115,1,0,0,0,117,118,1,0,
        0,0,118,120,1,0,0,0,119,117,1,0,0,0,120,124,5,20,0,0,121,123,3,14,
        7,0,122,121,1,0,0,0,123,126,1,0,0,0,124,122,1,0,0,0,124,125,1,0,
        0,0,125,127,1,0,0,0,126,124,1,0,0,0,127,128,5,21,0,0,128,9,1,0,0,
        0,129,130,5,17,0,0,130,131,5,7,0,0,131,132,5,23,0,0,132,133,3,12,
        6,0,133,11,1,0,0,0,134,135,7,0,0,0,135,13,1,0,0,0,136,138,5,1,0,
        0,137,136,1,0,0,0,137,138,1,0,0,0,138,139,1,0,0,0,139,140,5,2,0,
        0,140,143,5,17,0,0,141,142,5,4,0,0,142,144,5,17,0,0,143,141,1,0,
        0,0,143,144,1,0,0,0,144,148,1,0,0,0,145,147,3,10,5,0,146,145,1,0,
        0,0,147,150,1,0,0,0,148,146,1,0,0,0,148,149,1,0,0,0,149,151,1,0,
        0,0,150,148,1,0,0,0,151,156,5,20,0,0,152,155,3,16,8,0,153,155,3,
        64,32,0,154,152,1,0,0,0,154,153,1,0,0,0,155,158,1,0,0,0,156,154,
        1,0,0,0,156,157,1,0,0,0,157,159,1,0,0,0,158,156,1,0,0,0,159,160,
        5,21,0,0,160,15,1,0,0,0,161,162,3,18,9,0,162,166,5,17,0,0,163,165,
        3,20,10,0,164,163,1,0,0,0,165,168,1,0,0,0,166,164,1,0,0,0,166,167,
        1,0,0,0,167,170,1,0,0,0,168,166,1,0,0,0,169,171,3,22,11,0,170,169,
        1,0,0,0,170,171,1,0,0,0,171,173,1,0,0,0,172,174,3,28,14,0,173,172,
        1,0,0,0,173,174,1,0,0,0,174,178,1,0,0,0,175,177,3,10,5,0,176,175,
        1,0,0,0,177,180,1,0,0,0,178,176,1,0,0,0,178,179,1,0,0,0,179,184,
        1,0,0,0,180,178,1,0,0,0,181,183,3,40,20,0,182,181,1,0,0,0,183,186,
        1,0,0,0,184,182,1,0,0,0,184,185,1,0,0,0,185,188,1,0,0,0,186,184,
        1,0,0,0,187,189,3,58,29,0,188,187,1,0,0,0,188,189,1,0,0,0,189,191,
        1,0,0,0,190,192,3,60,30,0,191,190,1,0,0,0,191,192,1,0,0,0,192,17,
        1,0,0,0,193,194,7,1,0,0,194,19,1,0,0,0,195,196,5,40,0,0,196,197,
        5,17,0,0,197,21,1,0,0,0,198,199,5,20,0,0,199,204,3,24,12,0,200,201,
        5,44,0,0,201,203,3,24,12,0,202,200,1,0,0,0,203,206,1,0,0,0,204,202,
        1,0,0,0,204,205,1,0,0,0,205,207,1,0,0,0,206,204,1,0,0,0,207,208,
        5,21,0,0,208,23,1,0,0,0,209,210,7,2,0,0,210,25,1,0,0,0,211,212,3,
        28,14,0,212,27,1,0,0,0,213,214,5,26,0,0,214,215,3,30,15,0,215,216,
        5,27,0,0,216,29,1,0,0,0,217,222,3,32,16,0,218,219,7,3,0,0,219,221,
        3,32,16,0,220,218,1,0,0,0,221,224,1,0,0,0,222,220,1,0,0,0,222,223,
        1,0,0,0,223,31,1,0,0,0,224,222,1,0,0,0,225,230,3,34,17,0,226,227,
        7,4,0,0,227,229,3,34,17,0,228,226,1,0,0,0,229,232,1,0,0,0,230,228,
        1,0,0,0,230,231,1,0,0,0,231,33,1,0,0,0,232,230,1,0,0,0,233,236,3,
        36,18,0,234,235,5,47,0,0,235,237,3,36,18,0,236,234,1,0,0,0,236,237,
        1,0,0,0,237,35,1,0,0,0,238,245,3,38,19,0,239,240,5,18,0,0,240,241,
        3,30,15,0,241,242,5,19,0,0,242,245,1,0,0,0,243,245,3,62,31,0,244,
        238,1,0,0,0,244,239,1,0,0,0,244,243,1,0,0,0,245,37,1,0,0,0,246,259,
        5,17,0,0,247,256,5,18,0,0,248,253,3,62,31,0,249,250,5,44,0,0,250,
        252,3,62,31,0,251,249,1,0,0,0,252,255,1,0,0,0,253,251,1,0,0,0,253,
        254,1,0,0,0,254,257,1,0,0,0,255,253,1,0,0,0,256,248,1,0,0,0,256,
        257,1,0,0,0,257,258,1,0,0,0,258,260,5,19,0,0,259,247,1,0,0,0,259,
        260,1,0,0,0,260,39,1,0,0,0,261,263,3,42,21,0,262,264,3,44,22,0,263,
        262,1,0,0,0,263,264,1,0,0,0,264,265,1,0,0,0,265,267,3,46,23,0,266,
        268,3,54,27,0,267,266,1,0,0,0,267,268,1,0,0,0,268,270,1,0,0,0,269,
        271,3,56,28,0,270,269,1,0,0,0,270,271,1,0,0,0,271,41,1,0,0,0,272,
        273,7,5,0,0,273,43,1,0,0,0,274,279,5,17,0,0,275,276,5,35,0,0,276,
        278,5,17,0,0,277,275,1,0,0,0,278,281,1,0,0,0,279,277,1,0,0,0,279,
        280,1,0,0,0,280,45,1,0,0,0,281,279,1,0,0,0,282,283,5,18,0,0,283,
        288,3,48,24,0,284,285,5,44,0,0,285,287,3,48,24,0,286,284,1,0,0,0,
        287,290,1,0,0,0,288,286,1,0,0,0,288,289,1,0,0,0,289,291,1,0,0,0,
        290,288,1,0,0,0,291,292,5,19,0,0,292,47,1,0,0,0,293,294,3,50,25,
        0,294,295,3,52,26,0,295,49,1,0,0,0,296,297,5,17,0,0,297,51,1,0,0,
        0,298,299,5,17,0,0,299,53,1,0,0,0,300,301,5,17,0,0,301,55,1,0,0,
        0,302,303,3,28,14,0,303,57,1,0,0,0,304,305,5,41,0,0,305,310,3,66,
        33,0,306,307,5,44,0,0,307,309,3,66,33,0,308,306,1,0,0,0,309,312,
        1,0,0,0,310,308,1,0,0,0,310,311,1,0,0,0,311,59,1,0,0,0,312,310,1,
        0,0,0,313,314,7,6,0,0,314,319,3,66,33,0,315,316,5,44,0,0,316,318,
        3,66,33,0,317,315,1,0,0,0,318,321,1,0,0,0,319,317,1,0,0,0,319,320,
        1,0,0,0,320,61,1,0,0,0,321,319,1,0,0,0,322,323,7,7,0,0,323,63,1,
        0,0,0,324,325,5,8,0,0,325,326,5,17,0,0,326,327,5,30,0,0,327,328,
        3,66,33,0,328,65,1,0,0,0,329,335,3,68,34,0,330,331,3,76,38,0,331,
        332,3,68,34,0,332,334,1,0,0,0,333,330,1,0,0,0,334,337,1,0,0,0,335,
        333,1,0,0,0,335,336,1,0,0,0,336,67,1,0,0,0,337,335,1,0,0,0,338,343,
        3,70,35,0,339,340,5,35,0,0,340,342,3,70,35,0,341,339,1,0,0,0,342,
        345,1,0,0,0,343,341,1,0,0,0,343,344,1,0,0,0,344,69,1,0,0,0,345,343,
        1,0,0,0,346,347,5,18,0,0,347,348,3,66,33,0,348,349,5,19,0,0,349,
        356,1,0,0,0,350,351,3,72,36,0,351,352,5,18,0,0,352,353,5,19,0,0,
        353,356,1,0,0,0,354,356,5,17,0,0,355,346,1,0,0,0,355,350,1,0,0,0,
        355,354,1,0,0,0,356,358,1,0,0,0,357,359,5,28,0,0,358,357,1,0,0,0,
        358,359,1,0,0,0,359,363,1,0,0,0,360,362,3,74,37,0,361,360,1,0,0,
        0,362,365,1,0,0,0,363,361,1,0,0,0,363,364,1,0,0,0,364,71,1,0,0,0,
        365,363,1,0,0,0,366,367,5,17,0,0,367,73,1,0,0,0,368,369,5,26,0,0,
        369,370,5,17,0,0,370,371,5,27,0,0,371,75,1,0,0,0,372,373,7,8,0,0,
        373,77,1,0,0,0,374,375,5,3,0,0,375,379,5,20,0,0,376,378,3,80,40,
        0,377,376,1,0,0,0,378,381,1,0,0,0,379,377,1,0,0,0,379,380,1,0,0,
        0,380,382,1,0,0,0,381,379,1,0,0,0,382,383,5,21,0,0,383,79,1,0,0,
        0,384,385,5,17,0,0,385,386,3,82,41,0,386,387,3,84,42,0,387,388,5,
        24,0,0,388,389,3,88,44,0,389,390,5,25,0,0,390,391,3,84,42,0,391,
        392,3,82,41,0,392,396,5,17,0,0,393,395,3,10,5,0,394,393,1,0,0,0,
        395,398,1,0,0,0,396,394,1,0,0,0,396,397,1,0,0,0,397,81,1,0,0,0,398,
        396,1,0,0,0,399,400,5,26,0,0,400,401,5,17,0,0,401,402,5,27,0,0,402,
        83,1,0,0,0,403,406,3,86,43,0,404,405,5,34,0,0,405,407,3,86,43,0,
        406,404,1,0,0,0,406,407,1,0,0,0,407,85,1,0,0,0,408,409,7,9,0,0,409,
        87,1,0,0,0,410,411,5,17,0,0,411,89,1,0,0,0,40,93,96,102,117,124,
        137,143,148,154,156,166,170,173,178,184,188,191,204,222,230,236,
        244,253,256,259,263,267,270,279,288,310,319,335,343,355,358,363,
        379,396,406
    ]

class malParser ( Parser ):

    grammarFileName = "mal.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'abstract'", "'asset'", "'associations'", 
                     "'extends'", "'include'", "'category'", "'info'", "'let'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'E'", "'C'", "'I'", "'A'", "<INVALID>", "'('", "')'", 
                     "'{'", "'}'", "'#'", "':'", "'<--'", "'-->'", "'['", 
                     "']'", "'*'", "'1'", "'='", "'-'", "'/\\'", "'\\/'", 
                     "'..'", "'.'", "'&'", "'|'", "'!'", "'!E'", "'@'", 
                     "'<-'", "'+>'", "'->'", "','", "'+'", "'/'", "'^'", 
                     "'//!'" ]

    symbolicNames = [ "<INVALID>", "ABSTRACT", "ASSET", "ASSOCIATIONS", 
                      "EXTENDS", "INCLUDE", "CATEGORY", "INFO", "LET", "STRING", 
                      "MULTILINE_STRING", "INT", "FLOAT", "EXISTS", "C", 
                      "I", "A", "ID", "LPAREN", "RPAREN", "LCURLY", "RCURLY", 
                      "HASH", "COLON", "LARROW", "RARROW", "LSQUARE", "RSQUARE", 
                      "STAR", "ONE", "ASSIGN", "MINUS", "INTERSECT", "UNION", 
                      "RANGE", "DOT", "AND", "OR", "EXCLAMATION", "NOTEXISTS", 
                      "AT", "REQUIRES", "INHERITS", "LEADSTO", "COMMA", 
                      "PLUS", "DIVIDE", "POWER", "EXCLM_COMM", "INLINE_COMMENT", 
                      "MULTILINE_COMMENT", "WS" ]

    RULE_mal = 0
    RULE_declaration = 1
    RULE_include = 2
    RULE_define = 3
    RULE_category = 4
    RULE_meta = 5
    RULE_text = 6
    RULE_asset = 7
    RULE_step = 8
    RULE_steptype = 9
    RULE_tag = 10
    RULE_cias = 11
    RULE_cia = 12
    RULE_ttc = 13
    RULE_pdist = 14
    RULE_pdistexpr = 15
    RULE_pdistterm = 16
    RULE_pdistfact = 17
    RULE_pdistatom = 18
    RULE_pdistdist = 19
    RULE_detector = 20
    RULE_bang = 21
    RULE_detectorname = 22
    RULE_context = 23
    RULE_contextpart = 24
    RULE_contextasset = 25
    RULE_contextlabel = 26
    RULE_detectortype = 27
    RULE_tprate = 28
    RULE_precondition = 29
    RULE_reaches = 30
    RULE_number = 31
    RULE_variable = 32
    RULE_expr = 33
    RULE_parts = 34
    RULE_part = 35
    RULE_varsubst = 36
    RULE_type = 37
    RULE_setop = 38
    RULE_associations = 39
    RULE_association = 40
    RULE_field = 41
    RULE_mult = 42
    RULE_multatom = 43
    RULE_linkname = 44

    ruleNames =  [ "mal", "declaration", "include", "define", "category", 
                   "meta", "text", "asset", "step", "steptype", "tag", "cias", 
                   "cia", "ttc", "pdist", "pdistexpr", "pdistterm", "pdistfact", 
                   "pdistatom", "pdistdist", "detector", "bang", "detectorname", 
                   "context", "contextpart", "contextasset", "contextlabel", 
                   "detectortype", "tprate", "precondition", "reaches", 
                   "number", "variable", "expr", "parts", "part", "varsubst", 
                   "type", "setop", "associations", "association", "field", 
                   "mult", "multatom", "linkname" ]

    EOF = Token.EOF
    ABSTRACT=1
    ASSET=2
    ASSOCIATIONS=3
    EXTENDS=4
    INCLUDE=5
    CATEGORY=6
    INFO=7
    LET=8
    STRING=9
    MULTILINE_STRING=10
    INT=11
    FLOAT=12
    EXISTS=13
    C=14
    I=15
    A=16
    ID=17
    LPAREN=18
    RPAREN=19
    LCURLY=20
    RCURLY=21
    HASH=22
    COLON=23
    LARROW=24
    RARROW=25
    LSQUARE=26
    RSQUARE=27
    STAR=28
    ONE=29
    ASSIGN=30
    MINUS=31
    INTERSECT=32
    UNION=33
    RANGE=34
    DOT=35
    AND=36
    OR=37
    EXCLAMATION=38
    NOTEXISTS=39
    AT=40
    REQUIRES=41
    INHERITS=42
    LEADSTO=43
    COMMA=44
    PLUS=45
    DIVIDE=46
    POWER=47
    EXCLM_COMM=48
    INLINE_COMMENT=49
    MULTILINE_COMMENT=50
    WS=51

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class MalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(malParser.DeclarationContext,i)


        def EOF(self):
            return self.getToken(malParser.EOF, 0)

        def getRuleIndex(self):
            return malParser.RULE_mal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMal" ):
                listener.enterMal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMal" ):
                listener.exitMal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMal" ):
                return visitor.visitMal(self)
            else:
                return visitor.visitChildren(self)




    def mal(self):

        localctx = malParser.MalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_mal)
        self._la = 0 # Token type
        try:
            self.state = 96
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 5, 6, 22]:
                self.enterOuterAlt(localctx, 1)
                self.state = 91 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 90
                    self.declaration()
                    self.state = 93 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4194408) != 0)):
                        break

                pass
            elif token in [-1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 95
                self.match(malParser.EOF)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def include(self):
            return self.getTypedRuleContext(malParser.IncludeContext,0)


        def define(self):
            return self.getTypedRuleContext(malParser.DefineContext,0)


        def category(self):
            return self.getTypedRuleContext(malParser.CategoryContext,0)


        def associations(self):
            return self.getTypedRuleContext(malParser.AssociationsContext,0)


        def getRuleIndex(self):
            return malParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration" ):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = malParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_declaration)
        try:
            self.state = 102
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 98
                self.include()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 2)
                self.state = 99
                self.define()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 100
                self.category()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 4)
                self.state = 101
                self.associations()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(malParser.INCLUDE, 0)

        def STRING(self):
            return self.getToken(malParser.STRING, 0)

        def getRuleIndex(self):
            return malParser.RULE_include

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude" ):
                listener.enterInclude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude" ):
                listener.exitInclude(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInclude" ):
                return visitor.visitInclude(self)
            else:
                return visitor.visitChildren(self)




    def include(self):

        localctx = malParser.IncludeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_include)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.match(malParser.INCLUDE)
            self.state = 105
            self.match(malParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASH(self):
            return self.getToken(malParser.HASH, 0)

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def COLON(self):
            return self.getToken(malParser.COLON, 0)

        def STRING(self):
            return self.getToken(malParser.STRING, 0)

        def getRuleIndex(self):
            return malParser.RULE_define

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefine" ):
                listener.enterDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefine" ):
                listener.exitDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefine" ):
                return visitor.visitDefine(self)
            else:
                return visitor.visitChildren(self)




    def define(self):

        localctx = malParser.DefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_define)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self.match(malParser.HASH)
            self.state = 108
            self.match(malParser.ID)
            self.state = 109
            self.match(malParser.COLON)
            self.state = 110
            self.match(malParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CategoryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CATEGORY(self):
            return self.getToken(malParser.CATEGORY, 0)

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def LCURLY(self):
            return self.getToken(malParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(malParser.RCURLY, 0)

        def meta(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.MetaContext)
            else:
                return self.getTypedRuleContext(malParser.MetaContext,i)


        def asset(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.AssetContext)
            else:
                return self.getTypedRuleContext(malParser.AssetContext,i)


        def getRuleIndex(self):
            return malParser.RULE_category

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCategory" ):
                listener.enterCategory(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCategory" ):
                listener.exitCategory(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCategory" ):
                return visitor.visitCategory(self)
            else:
                return visitor.visitChildren(self)




    def category(self):

        localctx = malParser.CategoryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_category)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.match(malParser.CATEGORY)
            self.state = 113
            self.match(malParser.ID)
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==17:
                self.state = 114
                self.meta()
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 120
            self.match(malParser.LCURLY)
            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1 or _la==2:
                self.state = 121
                self.asset()
                self.state = 126
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 127
            self.match(malParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def INFO(self):
            return self.getToken(malParser.INFO, 0)

        def COLON(self):
            return self.getToken(malParser.COLON, 0)

        def text(self):
            return self.getTypedRuleContext(malParser.TextContext,0)


        def getRuleIndex(self):
            return malParser.RULE_meta

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeta" ):
                listener.enterMeta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeta" ):
                listener.exitMeta(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMeta" ):
                return visitor.visitMeta(self)
            else:
                return visitor.visitChildren(self)




    def meta(self):

        localctx = malParser.MetaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_meta)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(malParser.ID)
            self.state = 130
            self.match(malParser.INFO)
            self.state = 131
            self.match(malParser.COLON)
            self.state = 132
            self.text()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(malParser.STRING, 0)

        def MULTILINE_STRING(self):
            return self.getToken(malParser.MULTILINE_STRING, 0)

        def getRuleIndex(self):
            return malParser.RULE_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterText" ):
                listener.enterText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitText" ):
                listener.exitText(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitText" ):
                return visitor.visitText(self)
            else:
                return visitor.visitChildren(self)




    def text(self):

        localctx = malParser.TextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_text)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            _la = self._input.LA(1)
            if not(_la==9 or _la==10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSET(self):
            return self.getToken(malParser.ASSET, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.ID)
            else:
                return self.getToken(malParser.ID, i)

        def LCURLY(self):
            return self.getToken(malParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(malParser.RCURLY, 0)

        def ABSTRACT(self):
            return self.getToken(malParser.ABSTRACT, 0)

        def EXTENDS(self):
            return self.getToken(malParser.EXTENDS, 0)

        def meta(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.MetaContext)
            else:
                return self.getTypedRuleContext(malParser.MetaContext,i)


        def step(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.StepContext)
            else:
                return self.getTypedRuleContext(malParser.StepContext,i)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.VariableContext)
            else:
                return self.getTypedRuleContext(malParser.VariableContext,i)


        def getRuleIndex(self):
            return malParser.RULE_asset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAsset" ):
                listener.enterAsset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAsset" ):
                listener.exitAsset(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAsset" ):
                return visitor.visitAsset(self)
            else:
                return visitor.visitChildren(self)




    def asset(self):

        localctx = malParser.AssetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_asset)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 136
                self.match(malParser.ABSTRACT)


            self.state = 139
            self.match(malParser.ASSET)
            self.state = 140
            self.match(malParser.ID)
            self.state = 143
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 141
                self.match(malParser.EXTENDS)
                self.state = 142
                self.match(malParser.ID)


            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==17:
                self.state = 145
                self.meta()
                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 151
            self.match(malParser.LCURLY)
            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 755918446848) != 0):
                self.state = 154
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13, 22, 36, 37, 39]:
                    self.state = 152
                    self.step()
                    pass
                elif token in [8]:
                    self.state = 153
                    self.variable()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 158
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 159
            self.match(malParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StepContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def steptype(self):
            return self.getTypedRuleContext(malParser.SteptypeContext,0)


        def ID(self):
            return self.getToken(malParser.ID, 0)

        def tag(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.TagContext)
            else:
                return self.getTypedRuleContext(malParser.TagContext,i)


        def cias(self):
            return self.getTypedRuleContext(malParser.CiasContext,0)


        def pdist(self):
            return self.getTypedRuleContext(malParser.PdistContext,0)


        def meta(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.MetaContext)
            else:
                return self.getTypedRuleContext(malParser.MetaContext,i)


        def detector(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.DetectorContext)
            else:
                return self.getTypedRuleContext(malParser.DetectorContext,i)


        def precondition(self):
            return self.getTypedRuleContext(malParser.PreconditionContext,0)


        def reaches(self):
            return self.getTypedRuleContext(malParser.ReachesContext,0)


        def getRuleIndex(self):
            return malParser.RULE_step

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStep" ):
                listener.enterStep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStep" ):
                listener.exitStep(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStep" ):
                return visitor.visitStep(self)
            else:
                return visitor.visitChildren(self)




    def step(self):

        localctx = malParser.StepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_step)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self.steptype()
            self.state = 162
            self.match(malParser.ID)
            self.state = 166
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==40:
                self.state = 163
                self.tag()
                self.state = 168
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 169
                self.cias()


            self.state = 173
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 172
                self.pdist()


            self.state = 178
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==17:
                self.state = 175
                self.meta()
                self.state = 180
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==38 or _la==48:
                self.state = 181
                self.detector()
                self.state = 186
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 187
                self.precondition()


            self.state = 191
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42 or _la==43:
                self.state = 190
                self.reaches()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SteptypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(malParser.AND, 0)

        def OR(self):
            return self.getToken(malParser.OR, 0)

        def HASH(self):
            return self.getToken(malParser.HASH, 0)

        def EXISTS(self):
            return self.getToken(malParser.EXISTS, 0)

        def NOTEXISTS(self):
            return self.getToken(malParser.NOTEXISTS, 0)

        def getRuleIndex(self):
            return malParser.RULE_steptype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSteptype" ):
                listener.enterSteptype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSteptype" ):
                listener.exitSteptype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSteptype" ):
                return visitor.visitSteptype(self)
            else:
                return visitor.visitChildren(self)




    def steptype(self):

        localctx = malParser.SteptypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_steptype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 755918446592) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TagContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(malParser.AT, 0)

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def getRuleIndex(self):
            return malParser.RULE_tag

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTag" ):
                listener.enterTag(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTag" ):
                listener.exitTag(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTag" ):
                return visitor.visitTag(self)
            else:
                return visitor.visitChildren(self)




    def tag(self):

        localctx = malParser.TagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_tag)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(malParser.AT)
            self.state = 196
            self.match(malParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CiasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LCURLY(self):
            return self.getToken(malParser.LCURLY, 0)

        def cia(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.CiaContext)
            else:
                return self.getTypedRuleContext(malParser.CiaContext,i)


        def RCURLY(self):
            return self.getToken(malParser.RCURLY, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.COMMA)
            else:
                return self.getToken(malParser.COMMA, i)

        def getRuleIndex(self):
            return malParser.RULE_cias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCias" ):
                listener.enterCias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCias" ):
                listener.exitCias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCias" ):
                return visitor.visitCias(self)
            else:
                return visitor.visitChildren(self)




    def cias(self):

        localctx = malParser.CiasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_cias)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(malParser.LCURLY)
            self.state = 199
            self.cia()
            self.state = 204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 200
                self.match(malParser.COMMA)
                self.state = 201
                self.cia()
                self.state = 206
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 207
            self.match(malParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CiaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def C(self):
            return self.getToken(malParser.C, 0)

        def I(self):
            return self.getToken(malParser.I, 0)

        def A(self):
            return self.getToken(malParser.A, 0)

        def getRuleIndex(self):
            return malParser.RULE_cia

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCia" ):
                listener.enterCia(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCia" ):
                listener.exitCia(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCia" ):
                return visitor.visitCia(self)
            else:
                return visitor.visitChildren(self)




    def cia(self):

        localctx = malParser.CiaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_cia)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 114688) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TtcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pdist(self):
            return self.getTypedRuleContext(malParser.PdistContext,0)


        def getRuleIndex(self):
            return malParser.RULE_ttc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTtc" ):
                listener.enterTtc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTtc" ):
                listener.exitTtc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTtc" ):
                return visitor.visitTtc(self)
            else:
                return visitor.visitChildren(self)




    def ttc(self):

        localctx = malParser.TtcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_ttc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.pdist()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LSQUARE(self):
            return self.getToken(malParser.LSQUARE, 0)

        def pdistexpr(self):
            return self.getTypedRuleContext(malParser.PdistexprContext,0)


        def RSQUARE(self):
            return self.getToken(malParser.RSQUARE, 0)

        def getRuleIndex(self):
            return malParser.RULE_pdist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdist" ):
                listener.enterPdist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdist" ):
                listener.exitPdist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdist" ):
                return visitor.visitPdist(self)
            else:
                return visitor.visitChildren(self)




    def pdist(self):

        localctx = malParser.PdistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_pdist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(malParser.LSQUARE)
            self.state = 214
            self.pdistexpr()
            self.state = 215
            self.match(malParser.RSQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdistexprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pdistterm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.PdisttermContext)
            else:
                return self.getTypedRuleContext(malParser.PdisttermContext,i)


        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.PLUS)
            else:
                return self.getToken(malParser.PLUS, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.MINUS)
            else:
                return self.getToken(malParser.MINUS, i)

        def getRuleIndex(self):
            return malParser.RULE_pdistexpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdistexpr" ):
                listener.enterPdistexpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdistexpr" ):
                listener.exitPdistexpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdistexpr" ):
                return visitor.visitPdistexpr(self)
            else:
                return visitor.visitChildren(self)




    def pdistexpr(self):

        localctx = malParser.PdistexprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_pdistexpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 217
            self.pdistterm()
            self.state = 222
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or _la==45:
                self.state = 218
                _la = self._input.LA(1)
                if not(_la==31 or _la==45):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 219
                self.pdistterm()
                self.state = 224
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdisttermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pdistfact(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.PdistfactContext)
            else:
                return self.getTypedRuleContext(malParser.PdistfactContext,i)


        def STAR(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.STAR)
            else:
                return self.getToken(malParser.STAR, i)

        def DIVIDE(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.DIVIDE)
            else:
                return self.getToken(malParser.DIVIDE, i)

        def getRuleIndex(self):
            return malParser.RULE_pdistterm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdistterm" ):
                listener.enterPdistterm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdistterm" ):
                listener.exitPdistterm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdistterm" ):
                return visitor.visitPdistterm(self)
            else:
                return visitor.visitChildren(self)




    def pdistterm(self):

        localctx = malParser.PdisttermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_pdistterm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self.pdistfact()
            self.state = 230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==28 or _la==46:
                self.state = 226
                _la = self._input.LA(1)
                if not(_la==28 or _la==46):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 227
                self.pdistfact()
                self.state = 232
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdistfactContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pdistatom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.PdistatomContext)
            else:
                return self.getTypedRuleContext(malParser.PdistatomContext,i)


        def POWER(self):
            return self.getToken(malParser.POWER, 0)

        def getRuleIndex(self):
            return malParser.RULE_pdistfact

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdistfact" ):
                listener.enterPdistfact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdistfact" ):
                listener.exitPdistfact(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdistfact" ):
                return visitor.visitPdistfact(self)
            else:
                return visitor.visitChildren(self)




    def pdistfact(self):

        localctx = malParser.PdistfactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_pdistfact)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.pdistatom()
            self.state = 236
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==47:
                self.state = 234
                self.match(malParser.POWER)
                self.state = 235
                self.pdistatom()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdistatomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pdistdist(self):
            return self.getTypedRuleContext(malParser.PdistdistContext,0)


        def LPAREN(self):
            return self.getToken(malParser.LPAREN, 0)

        def pdistexpr(self):
            return self.getTypedRuleContext(malParser.PdistexprContext,0)


        def RPAREN(self):
            return self.getToken(malParser.RPAREN, 0)

        def number(self):
            return self.getTypedRuleContext(malParser.NumberContext,0)


        def getRuleIndex(self):
            return malParser.RULE_pdistatom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdistatom" ):
                listener.enterPdistatom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdistatom" ):
                listener.exitPdistatom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdistatom" ):
                return visitor.visitPdistatom(self)
            else:
                return visitor.visitChildren(self)




    def pdistatom(self):

        localctx = malParser.PdistatomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_pdistatom)
        try:
            self.state = 244
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 238
                self.pdistdist()
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 239
                self.match(malParser.LPAREN)
                self.state = 240
                self.pdistexpr()
                self.state = 241
                self.match(malParser.RPAREN)
                pass
            elif token in [11, 12]:
                self.enterOuterAlt(localctx, 3)
                self.state = 243
                self.number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdistdistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def LPAREN(self):
            return self.getToken(malParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(malParser.RPAREN, 0)

        def number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.NumberContext)
            else:
                return self.getTypedRuleContext(malParser.NumberContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.COMMA)
            else:
                return self.getToken(malParser.COMMA, i)

        def getRuleIndex(self):
            return malParser.RULE_pdistdist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdistdist" ):
                listener.enterPdistdist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdistdist" ):
                listener.exitPdistdist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdistdist" ):
                return visitor.visitPdistdist(self)
            else:
                return visitor.visitChildren(self)




    def pdistdist(self):

        localctx = malParser.PdistdistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_pdistdist)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            self.match(malParser.ID)
            self.state = 259
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==18:
                self.state = 247
                self.match(malParser.LPAREN)
                self.state = 256
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==11 or _la==12:
                    self.state = 248
                    self.number()
                    self.state = 253
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==44:
                        self.state = 249
                        self.match(malParser.COMMA)
                        self.state = 250
                        self.number()
                        self.state = 255
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 258
                self.match(malParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DetectorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bang(self):
            return self.getTypedRuleContext(malParser.BangContext,0)


        def context(self):
            return self.getTypedRuleContext(malParser.ContextContext,0)


        def detectorname(self):
            return self.getTypedRuleContext(malParser.DetectornameContext,0)


        def detectortype(self):
            return self.getTypedRuleContext(malParser.DetectortypeContext,0)


        def tprate(self):
            return self.getTypedRuleContext(malParser.TprateContext,0)


        def getRuleIndex(self):
            return malParser.RULE_detector

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDetector" ):
                listener.enterDetector(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDetector" ):
                listener.exitDetector(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDetector" ):
                return visitor.visitDetector(self)
            else:
                return visitor.visitChildren(self)




    def detector(self):

        localctx = malParser.DetectorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_detector)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.bang()
            self.state = 263
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 262
                self.detectorname()


            self.state = 265
            self.context()
            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 266
                self.detectortype()


            self.state = 270
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 269
                self.tprate()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BangContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLAMATION(self):
            return self.getToken(malParser.EXCLAMATION, 0)

        def EXCLM_COMM(self):
            return self.getToken(malParser.EXCLM_COMM, 0)

        def getRuleIndex(self):
            return malParser.RULE_bang

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBang" ):
                listener.enterBang(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBang" ):
                listener.exitBang(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBang" ):
                return visitor.visitBang(self)
            else:
                return visitor.visitChildren(self)




    def bang(self):

        localctx = malParser.BangContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_bang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            _la = self._input.LA(1)
            if not(_la==38 or _la==48):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DetectornameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.ID)
            else:
                return self.getToken(malParser.ID, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.DOT)
            else:
                return self.getToken(malParser.DOT, i)

        def getRuleIndex(self):
            return malParser.RULE_detectorname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDetectorname" ):
                listener.enterDetectorname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDetectorname" ):
                listener.exitDetectorname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDetectorname" ):
                return visitor.visitDetectorname(self)
            else:
                return visitor.visitChildren(self)




    def detectorname(self):

        localctx = malParser.DetectornameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_detectorname)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(malParser.ID)
            self.state = 279
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 275
                self.match(malParser.DOT)
                self.state = 276
                self.match(malParser.ID)
                self.state = 281
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContextContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(malParser.LPAREN, 0)

        def contextpart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.ContextpartContext)
            else:
                return self.getTypedRuleContext(malParser.ContextpartContext,i)


        def RPAREN(self):
            return self.getToken(malParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.COMMA)
            else:
                return self.getToken(malParser.COMMA, i)

        def getRuleIndex(self):
            return malParser.RULE_context

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContext" ):
                listener.enterContext(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContext" ):
                listener.exitContext(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContext" ):
                return visitor.visitContext(self)
            else:
                return visitor.visitChildren(self)




    def context(self):

        localctx = malParser.ContextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_context)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(malParser.LPAREN)
            self.state = 283
            self.contextpart()
            self.state = 288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 284
                self.match(malParser.COMMA)
                self.state = 285
                self.contextpart()
                self.state = 290
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 291
            self.match(malParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContextpartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def contextasset(self):
            return self.getTypedRuleContext(malParser.ContextassetContext,0)


        def contextlabel(self):
            return self.getTypedRuleContext(malParser.ContextlabelContext,0)


        def getRuleIndex(self):
            return malParser.RULE_contextpart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContextpart" ):
                listener.enterContextpart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContextpart" ):
                listener.exitContextpart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContextpart" ):
                return visitor.visitContextpart(self)
            else:
                return visitor.visitChildren(self)




    def contextpart(self):

        localctx = malParser.ContextpartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_contextpart)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.contextasset()
            self.state = 294
            self.contextlabel()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContextassetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def getRuleIndex(self):
            return malParser.RULE_contextasset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContextasset" ):
                listener.enterContextasset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContextasset" ):
                listener.exitContextasset(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContextasset" ):
                return visitor.visitContextasset(self)
            else:
                return visitor.visitChildren(self)




    def contextasset(self):

        localctx = malParser.ContextassetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_contextasset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.match(malParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContextlabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def getRuleIndex(self):
            return malParser.RULE_contextlabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContextlabel" ):
                listener.enterContextlabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContextlabel" ):
                listener.exitContextlabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContextlabel" ):
                return visitor.visitContextlabel(self)
            else:
                return visitor.visitChildren(self)




    def contextlabel(self):

        localctx = malParser.ContextlabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_contextlabel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self.match(malParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DetectortypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def getRuleIndex(self):
            return malParser.RULE_detectortype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDetectortype" ):
                listener.enterDetectortype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDetectortype" ):
                listener.exitDetectortype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDetectortype" ):
                return visitor.visitDetectortype(self)
            else:
                return visitor.visitChildren(self)




    def detectortype(self):

        localctx = malParser.DetectortypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_detectortype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(malParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TprateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pdist(self):
            return self.getTypedRuleContext(malParser.PdistContext,0)


        def getRuleIndex(self):
            return malParser.RULE_tprate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTprate" ):
                listener.enterTprate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTprate" ):
                listener.exitTprate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTprate" ):
                return visitor.visitTprate(self)
            else:
                return visitor.visitChildren(self)




    def tprate(self):

        localctx = malParser.TprateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_tprate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.pdist()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreconditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRES(self):
            return self.getToken(malParser.REQUIRES, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.ExprContext)
            else:
                return self.getTypedRuleContext(malParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.COMMA)
            else:
                return self.getToken(malParser.COMMA, i)

        def getRuleIndex(self):
            return malParser.RULE_precondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrecondition" ):
                listener.enterPrecondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrecondition" ):
                listener.exitPrecondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrecondition" ):
                return visitor.visitPrecondition(self)
            else:
                return visitor.visitChildren(self)




    def precondition(self):

        localctx = malParser.PreconditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_precondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(malParser.REQUIRES)
            self.state = 305
            self.expr()
            self.state = 310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 306
                self.match(malParser.COMMA)
                self.state = 307
                self.expr()
                self.state = 312
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReachesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.ExprContext)
            else:
                return self.getTypedRuleContext(malParser.ExprContext,i)


        def INHERITS(self):
            return self.getToken(malParser.INHERITS, 0)

        def LEADSTO(self):
            return self.getToken(malParser.LEADSTO, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.COMMA)
            else:
                return self.getToken(malParser.COMMA, i)

        def getRuleIndex(self):
            return malParser.RULE_reaches

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReaches" ):
                listener.enterReaches(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReaches" ):
                listener.exitReaches(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReaches" ):
                return visitor.visitReaches(self)
            else:
                return visitor.visitChildren(self)




    def reaches(self):

        localctx = malParser.ReachesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_reaches)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            _la = self._input.LA(1)
            if not(_la==42 or _la==43):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 314
            self.expr()
            self.state = 319
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 315
                self.match(malParser.COMMA)
                self.state = 316
                self.expr()
                self.state = 321
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(malParser.INT, 0)

        def FLOAT(self):
            return self.getToken(malParser.FLOAT, 0)

        def getRuleIndex(self):
            return malParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = malParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            _la = self._input.LA(1)
            if not(_la==11 or _la==12):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET(self):
            return self.getToken(malParser.LET, 0)

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def ASSIGN(self):
            return self.getToken(malParser.ASSIGN, 0)

        def expr(self):
            return self.getTypedRuleContext(malParser.ExprContext,0)


        def getRuleIndex(self):
            return malParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = malParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(malParser.LET)
            self.state = 325
            self.match(malParser.ID)
            self.state = 326
            self.match(malParser.ASSIGN)
            self.state = 327
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parts(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.PartsContext)
            else:
                return self.getTypedRuleContext(malParser.PartsContext,i)


        def setop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.SetopContext)
            else:
                return self.getTypedRuleContext(malParser.SetopContext,i)


        def getRuleIndex(self):
            return malParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = malParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            self.parts()
            self.state = 335
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 15032385536) != 0):
                self.state = 330
                self.setop()
                self.state = 331
                self.parts()
                self.state = 337
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def part(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.PartContext)
            else:
                return self.getTypedRuleContext(malParser.PartContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.DOT)
            else:
                return self.getToken(malParser.DOT, i)

        def getRuleIndex(self):
            return malParser.RULE_parts

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParts" ):
                listener.enterParts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParts" ):
                listener.exitParts(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParts" ):
                return visitor.visitParts(self)
            else:
                return visitor.visitChildren(self)




    def parts(self):

        localctx = malParser.PartsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_parts)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.part()
            self.state = 343
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 339
                self.match(malParser.DOT)
                self.state = 340
                self.part()
                self.state = 345
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(malParser.LPAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(malParser.ExprContext,0)


        def RPAREN(self):
            return self.getToken(malParser.RPAREN, 0)

        def varsubst(self):
            return self.getTypedRuleContext(malParser.VarsubstContext,0)


        def ID(self):
            return self.getToken(malParser.ID, 0)

        def STAR(self):
            return self.getToken(malParser.STAR, 0)

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.TypeContext)
            else:
                return self.getTypedRuleContext(malParser.TypeContext,i)


        def getRuleIndex(self):
            return malParser.RULE_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPart" ):
                listener.enterPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPart" ):
                listener.exitPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPart" ):
                return visitor.visitPart(self)
            else:
                return visitor.visitChildren(self)




    def part(self):

        localctx = malParser.PartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.state = 346
                self.match(malParser.LPAREN)
                self.state = 347
                self.expr()
                self.state = 348
                self.match(malParser.RPAREN)
                pass

            elif la_ == 2:
                self.state = 350
                self.varsubst()
                self.state = 351
                self.match(malParser.LPAREN)
                self.state = 352
                self.match(malParser.RPAREN)
                pass

            elif la_ == 3:
                self.state = 354
                self.match(malParser.ID)
                pass


            self.state = 358
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 357
                self.match(malParser.STAR)


            self.state = 363
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==26:
                self.state = 360
                self.type_()
                self.state = 365
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarsubstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def getRuleIndex(self):
            return malParser.RULE_varsubst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarsubst" ):
                listener.enterVarsubst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarsubst" ):
                listener.exitVarsubst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarsubst" ):
                return visitor.visitVarsubst(self)
            else:
                return visitor.visitChildren(self)




    def varsubst(self):

        localctx = malParser.VarsubstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_varsubst)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 366
            self.match(malParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LSQUARE(self):
            return self.getToken(malParser.LSQUARE, 0)

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def RSQUARE(self):
            return self.getToken(malParser.RSQUARE, 0)

        def getRuleIndex(self):
            return malParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType" ):
                return visitor.visitType(self)
            else:
                return visitor.visitChildren(self)




    def type_(self):

        localctx = malParser.TypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 368
            self.match(malParser.LSQUARE)
            self.state = 369
            self.match(malParser.ID)
            self.state = 370
            self.match(malParser.RSQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION(self):
            return self.getToken(malParser.UNION, 0)

        def INTERSECT(self):
            return self.getToken(malParser.INTERSECT, 0)

        def MINUS(self):
            return self.getToken(malParser.MINUS, 0)

        def getRuleIndex(self):
            return malParser.RULE_setop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetop" ):
                listener.enterSetop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetop" ):
                listener.exitSetop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetop" ):
                return visitor.visitSetop(self)
            else:
                return visitor.visitChildren(self)




    def setop(self):

        localctx = malParser.SetopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_setop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 15032385536) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssociationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSOCIATIONS(self):
            return self.getToken(malParser.ASSOCIATIONS, 0)

        def LCURLY(self):
            return self.getToken(malParser.LCURLY, 0)

        def RCURLY(self):
            return self.getToken(malParser.RCURLY, 0)

        def association(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.AssociationContext)
            else:
                return self.getTypedRuleContext(malParser.AssociationContext,i)


        def getRuleIndex(self):
            return malParser.RULE_associations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssociations" ):
                listener.enterAssociations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssociations" ):
                listener.exitAssociations(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssociations" ):
                return visitor.visitAssociations(self)
            else:
                return visitor.visitChildren(self)




    def associations(self):

        localctx = malParser.AssociationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_associations)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 374
            self.match(malParser.ASSOCIATIONS)
            self.state = 375
            self.match(malParser.LCURLY)
            self.state = 379
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==17:
                self.state = 376
                self.association()
                self.state = 381
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 382
            self.match(malParser.RCURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssociationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(malParser.ID)
            else:
                return self.getToken(malParser.ID, i)

        def field(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.FieldContext)
            else:
                return self.getTypedRuleContext(malParser.FieldContext,i)


        def mult(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.MultContext)
            else:
                return self.getTypedRuleContext(malParser.MultContext,i)


        def LARROW(self):
            return self.getToken(malParser.LARROW, 0)

        def linkname(self):
            return self.getTypedRuleContext(malParser.LinknameContext,0)


        def RARROW(self):
            return self.getToken(malParser.RARROW, 0)

        def meta(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.MetaContext)
            else:
                return self.getTypedRuleContext(malParser.MetaContext,i)


        def getRuleIndex(self):
            return malParser.RULE_association

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssociation" ):
                listener.enterAssociation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssociation" ):
                listener.exitAssociation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssociation" ):
                return visitor.visitAssociation(self)
            else:
                return visitor.visitChildren(self)




    def association(self):

        localctx = malParser.AssociationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_association)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 384
            self.match(malParser.ID)
            self.state = 385
            self.field()
            self.state = 386
            self.mult()
            self.state = 387
            self.match(malParser.LARROW)
            self.state = 388
            self.linkname()
            self.state = 389
            self.match(malParser.RARROW)
            self.state = 390
            self.mult()
            self.state = 391
            self.field()
            self.state = 392
            self.match(malParser.ID)
            self.state = 396
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 393
                    self.meta() 
                self.state = 398
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LSQUARE(self):
            return self.getToken(malParser.LSQUARE, 0)

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def RSQUARE(self):
            return self.getToken(malParser.RSQUARE, 0)

        def getRuleIndex(self):
            return malParser.RULE_field

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterField" ):
                listener.enterField(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitField" ):
                listener.exitField(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitField" ):
                return visitor.visitField(self)
            else:
                return visitor.visitChildren(self)




    def field(self):

        localctx = malParser.FieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_field)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            self.match(malParser.LSQUARE)
            self.state = 400
            self.match(malParser.ID)
            self.state = 401
            self.match(malParser.RSQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multatom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(malParser.MultatomContext)
            else:
                return self.getTypedRuleContext(malParser.MultatomContext,i)


        def RANGE(self):
            return self.getToken(malParser.RANGE, 0)

        def getRuleIndex(self):
            return malParser.RULE_mult

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMult" ):
                listener.enterMult(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMult" ):
                listener.exitMult(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMult" ):
                return visitor.visitMult(self)
            else:
                return visitor.visitChildren(self)




    def mult(self):

        localctx = malParser.MultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_mult)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            self.multatom()
            self.state = 406
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 404
                self.match(malParser.RANGE)
                self.state = 405
                self.multatom()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultatomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(malParser.INT, 0)

        def STAR(self):
            return self.getToken(malParser.STAR, 0)

        def getRuleIndex(self):
            return malParser.RULE_multatom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultatom" ):
                listener.enterMultatom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultatom" ):
                listener.exitMultatom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultatom" ):
                return visitor.visitMultatom(self)
            else:
                return visitor.visitChildren(self)




    def multatom(self):

        localctx = malParser.MultatomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_multatom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 408
            _la = self._input.LA(1)
            if not(_la==11 or _la==28):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LinknameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(malParser.ID, 0)

        def getRuleIndex(self):
            return malParser.RULE_linkname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLinkname" ):
                listener.enterLinkname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLinkname" ):
                listener.exitLinkname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLinkname" ):
                return visitor.visitLinkname(self)
            else:
                return visitor.visitChildren(self)




    def linkname(self):

        localctx = malParser.LinknameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_linkname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.match(malParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





